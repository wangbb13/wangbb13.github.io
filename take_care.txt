清橙
A1122 旅行家的预算  模拟+想清楚所有情况，贪心
A1123 邮票面值设计  搜索，确定搜索范围 + 动规
A1126 单词接龙      注意审题，想清楚细节后再编码
A1131 gcd和lcm      注意细节
A1135 数的划分      想清楚子问题
A1137 统计单词个数  降维DP+DP，想清楚子问题
A1138 Car的旅行路线 Dijkstra，单源最短路径
A1161 守望者的逃离  贪心
A1168 传纸条        简单的四维DP，不要想复杂
A1169 双栈排序      二分图，想清楚什么时候不能通过一个栈完成排序
A1173 道路游戏      DP，状态有时间、出现的工厂、走了几步到达工厂
A1176 最优贸易      确定哪些点是出现在到达终点的路径上，可以考虑从终点dfs
A1180 导弹拦截      排序+贪心，首先枚举所有可能的情况，为使问题更加清晰，增加排序操作
A1181 三国游戏      博弈题，第一次见……
A1183 乌龟棋        动态规划，找准状态
A1184 关押罪犯      并查集
A1185 引水入城      bfs+贪心，明确中间结果的特点
A1191 选择客栈      动态规划，不要想当然，考虑动规
A1194 聪明的质检员  二分，注意数据范围，必要时使用高精度（e.g. long long int），注意累计结果的作用，不要犯傻
A1195 观光公交      贪心，想清楚，模拟是否合适，优先寻找转移方程
A1358 积水          灌满后，将多余的水排出


软思源
week1 
……


lintcode
 91. 最小调整代价         动态规划，枚举每个状态可能的取值，状态转移
122. 直方图的最大覆盖     单调队列，两个，确定左右边界；单调栈
 81. 数据流的中位数       巧用数据结构，通过两个优先队列（堆）来确定中位数
  4. 丑数                 利用多个指针
155. 二叉树的最小深度     注意左右孩子指针为NULL的情况
 58. 四数之和             不是所有的题都要DP，注意枚举、排序的作用
139. 最接近0的子数组和    排序！排序！排序！
151. 买股票的最佳时机    动态规划，状态转移方程其实很直接，买卖股票今天只跟前一天的状态有关，所以确定状态，并确定转移方程即可。
602. 俄罗斯套娃信封       优先考虑能否通过适当调整数据（比如，顺序）来使得问题转化为已知的或较为容易解决的问题，不要太直接；最长递增子序列的O(nlogn)解法。
191. 乘积最大子序列       最大值、最小值
436. 最大正方形           从右下角判断，进行状态转移。
510. 最大矩形             可以转化为直方图的最大覆盖问题。
514. 栅栏染色             确定好状态，如果不好进行状态转移，则适当的增加状态
430. 攀爬字符串           多测试，考虑到尽可能多的情况
512. 解码方法             能用dp[]就用数组，不需要减少空间复杂度
516. 房屋染色II           O(nk)算法超时，要改进
 51. 上一个排列           同理
 52. 下一个排列           有规律可寻的，记住规律即可
 45. 最大子数组差         注意保存结果，不要重复计算
 42. 两个子数组最大和     同上


usaco
Cow pedigrees             DP，不要多想，直接写就好，dp[i][j]，N个节点，高度为j的数量


POJ:



小技巧：
对于环状序列，可以将序列复制一次放在后面
对于子序列的和，考虑s[i] := 前i个元素之和，那么子序列和s[i, j] = s[i] - s[j-1]，考虑累计（加、乘）的作用
递归回溯时，一定要确保不要有改变记录的值的操作，比如排序


其他：
Dijkstra算法：
问题：单源最短路径，从一个节点到其他节点的最短路径，有向图，权重非负
思想：每次从已扩展的节点中选择路径最短的节点，然后从此扩展，将此节点加入到已找到最短路径的节点集合中

Floyd-Warshall算法：
问题：所有节点对的最短路径，有向图，存在负权重的边（不能解决带负权重环路的图）
思想：最开始只允许经过 1 号顶点进行中转，接下来只允许经过 1 和 2 号顶点进行中转……允许经过 1~n 号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从 i 号顶点到 j 号顶点只经过前k号点的最短路程。
for(k=1;k<=n;k++)
  for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
      if(e[i][j]>e[i][k]+e[k][j])
        e[i][j]=e[i][k]+e[k][j];
很简洁。

prime算法：
问题：无向带权图最小生成树
思想：1. 清空生成树，任取一点加入树中；2.在所有一点在树中、一点不在树中的边里选取最小的一个加入树中；3.重复2，直至所有点加入树中。

kruskall算法：
问题：最小生成树
思想：由n个顶点，构造出一棵树，使用并查集即可。编程实现：排序+并查集，然后依次遍历，边的两个点不在同一集合中，则merge，否则忽略。

优先队列：最大值在前面。

多重背包问题：取值在1, 2, 4, 8, 2^k, amount - (1 + 2 + ... + 2^k) 中，切记!

双调欧几里得：
问题：平面上n个点，确定一条连接各点的最短闭合路径问题
状态转移方程：dp[i][j] = dp[i-1][j] + p[i][i-1], j < i-1
              dp[i][i-1] = min { dp[i-1][j] + p[j][i] }

谨慎编程，=和==不要写错了。。
谨慎编程，位运算一定要加括号！！
dfs注意考虑需不需要设置状态
最短路径还是优先bfs
查找路径时，考虑从源节点 -> 目标节点，反向考虑目标节点 -> 源节点
注意溢出问题

尽量用scanf和printf以减小输入、输出时间

不要想当然，尽可能去证明一下结论


类型：
动规、背包、贪心、搜索、二分、枚举、排序、模拟、数论、高精度
DS：
队列、堆、栈、单调队列、优先队列、多（双）指针、并查集


STL:
<string>: 字符串
大小：s.size() 或者 s.length()
截取：s.substr(pos, len)

<deque>: 双端队列（用于实现单调队列）
push_back
push_front
pop_back
pop_front

<map>: 底层数据结构：红黑树，因此数据是有序的
count(): 可以用来判断一个键值是否存在

<queue>:
empty(): 队列是否为空
front(): 访问队首元素
back():  访问队尾元素
push():
pop():

<priority_queue>: 优先队列
empty():
push():
pop():
top(): 访问堆顶元素

<stack>: 
empty():
push():
pop():
top(): 访问栈顶元素

<unordered_map>: 散列表，不再是红黑树作为底层数据结构


原则：
1. 前两道题一定要在1h内完成，为最后一道题预留出足够的时间
2. 对于复杂问题，首先想能否转化为已知的问题，这时需要头脑风暴，因此要记住常见的题目类型
3. 优先考虑动态规划、DFS/BFS、二分查找、贪心算法、模拟、枚举、排序（后面这两个不要忽略了）
4. 可能用到的数据结构有：队列（单调队列）、栈（单调栈）、堆（优先队列）、并查集、多（双）指针

Keep it Simple, Stupid
5. 如果想到最简单的版本，那么首先无错误编码出来，有时间再进行优化
6. 解决方案往往是优雅的，但修修补补也是可以理解的
7. DP时数组下标从1开始，减少不必要的麻烦
8. 能用DP数组就用数组，不需要减少空间复杂度，以免不必要的麻烦
9. 从正反两个方面来考虑问题

10. 调试过程只注释代码，不要删除
11. VS调试：F5调试，F10逐过程，F11逐语句（能够进入函数内部），Shift+F5停止调试，Ctl+F5运行
12. 二分查找：r = mid；l = mid + 1；条件：(l < r)
13. 不要在变量命名上纠结，候选：数组：dp, f, g, h, cnt, ipt, flag等，尽量简洁

14. 所有的时间用来冷静地思考问题、解决问题，其他的事情没有意义